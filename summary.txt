Question 1:  
Why did you choose the tools, libraries, and language you used for the coding exercise?

Answer 1:
The two main options I had for creating the API was Flask in Python or Node in JS. These have very good documentation and community support and have been in use in the industry for a long time – having considerable experience in both through previous internships and projects was obviously a bonus.
I finally settled on Flask because of the nature of the assignment. In a production environment, I have seen that node has better throughput and performance, parallelization and great compatibility with JSON objects, but since the assignment was so small and only for demonstrating functionality for a single user, I decided to go with the more lightweight option, i.e. Flask. I understood that throughput or parallelism might not be that big of a factor here, it would be a waste of resources to make a heavy API just for this purpose.
The second big choice I made was including tinyDB. I could have gotten away with just having an external file storing the data or a dynamic dictionary maintained as a global variable. However, it is important to recognize that this is not how production environments work, and this leads to a lot of security and efficiency issues. Thus, I wanted to demonstrate my understanding using a database. Sqlite was an obvious option here, but, NoSQL seemed like a more natural choice given the assignment requirements and use of JSON objects for API queries - hence TinyDB. I needed the database to be local so that the API could be run locally without any external dependencies. An added motivation for me was that I hadn’t previously used TinyDB, so I took this opportunity to learn something new.

Question 2:  
What are the advantages and disadvantages of your solution?
Answer 2: 
The obvious advantages would be that the API is built on flask and uses tinyDB to store data, making it fast. The corresponding disadvantage would be that it is not great at very high workloads, parallelization and throughput; tinyDB does not offer as many aggregation and query functionalities as a dedicated database leading to the requirement for me to code these aggregations inside the function calls themselves adding to the overhead.
I have additionally used global variables, which have certain security considerations and is generally considered bad practice. However, since we are dealing with a single template user, I have decided to still go with it. Considering this, if we ever want to extend the functionality of the same API to handle multiple users, my implementation would be able to do that with negligible code changes.
I would like to note a design choice that I made for what and how the data is stored. It has been my understanding that the most important functionality/ feature is being able to add points, see balance and spend the oldest points first. Currently, the way I have this configured makes it efficient to perform all these activities, but it falls short in maintaining a complete unblemished record of the transaction the user does, i.e. it does not perfectly maintain every point added and the original transaction, or every point spent. I will elaborate on that below:
Adding points maintains all transaction and they are entered in the database unchanged. A small caveat here – the writeup specified that it is possible to add negative points, which is equivalent to spending as many points. I have handled that case.
When spending however, I get transactions ordered by timestamps, and I change the original points in the transaction themselves in the database and reduce as many points as required and specified by the write up. I can deduct points till the oldest transaction points are not 0 signifying that the corresponding points have already been spent and then I move on. This ensures that no payer points become negative, and we spend only the oldest points that have yet not been spent. This poses the disadvantage that original transactions are not maintained and their values change over time – however, since maintaining a perfect record of the transactions was not a specific requirement I have decided to opt fir this design. Anyways if that was a requirement designing another microservice to keep track of all user actions might be a better option that enforcing it here or have an extra table to keep track of that.

Question 3:
What has been a favorite school/personal project thus far? What about it that challenged you?

Answer 3:
One of my favorite personal projects has been SkyClusters, an automated IaaS full-stack solution I built for provisioning VM clusters across cloud platforms like GCP, AWS, and Linode. One of the biggest challenges was choosing a microservices architecture and developing both the backend and frontend on my own, which meant constantly switching between the two and adapting to different contexts and paradigms. I used Flask and Node.js for the microservices, and the most difficult part was implementing the event-driven architecture with Kafka to ensure smooth communication between all the APIs while keeping everything efficient and scalable.

Building a sky computing solution, where users can avoid reliance on a single cloud provider, was complex but incredibly rewarding. It really pushed me to dive deep into distributed systems, cloud APIs, and automation with Terraform and Ansible. Doing everything myself taught me how to manage my time, take ownership of every component, and figure out the best way to integrate everything smoothly, ultimately making me a better, more well-rounded developer.